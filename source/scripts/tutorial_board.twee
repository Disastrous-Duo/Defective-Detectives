:: Tutorial Board [script]

(function(){ // self-containing function for scope purpose

  // To create a new board,
  //1.copy-paste this file, change the Twine scene name
  //2.change the this_board name variable
  //3. call window[this_board] init function at startup

  let this_board = "tutorial_board";
  window[this_board] = {};



  // Creates the HTML elements for the board
  let genButton = (name, functionName) => `<input type="button" value="${name}" onclick="${functionName}();" />`;

  let html_conspiracy_board =
  `
  <div id="${this_board+"_overlay"}" class="boards_overlay">
  <canvas id="${this_board+"_cvs"}"></canvas>
  </div>
  `;


  // Creates debug buttons
  //$(genButton("Toggle Board","window['"+this_board+"'].toggle_board")).insertAfter("#story-author");

  // Add board to HTML
  $(html_conspiracy_board).insertBefore("#passages");

  window[this_board].conspiracy_board_toggled = false;


  window[this_board].toggle_board = function()
  {
    window[this_board].conspiracy_board_toggled = !window[this_board].conspiracy_board_toggled;
    if(window[this_board].conspiracy_board_toggled)
    {
      $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_up");
      $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_down");
    }
    else
    {
      $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_down");
      $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_up");
    }
  };




  ////////////////////



// sizes for the canvas that is about to be resized
var parent = document.getElementById(`${this_board+"_overlay"}`);
var w = Math.round(parent.offsetWidth/2);
var h = Math.round(parent.offsetHeight/2);

  window[this_board].notesList = [
    {txt:"**MYSTERY**\nHow to use the conspiracy board?", x:w, y:h, type:"question"},
    {txt:"CLUE 1/5\n\n\n", x:w/2-10, y:h*2/3+10, type:"clue"},
    {txt:"CLUE 2/5\nClick a pin, then click another to connect them", x:w*3/2, y:h*2/3, type:"clue"},

    {txt:"CLUE 3/5\nMove notes by dragging them", x:  w/2+10 , y: h*6/4-10   +10, type:"front-hint"},
    {txt:"CLUE 4/5\nScroll to dezoom. Drag to move on the board", x:w/2+10  +40, y:h*6/4-10  +30, type:"clue"},

    {txt:"CLUE 5/5\n Oh no, you found me!", x:w*7/3, y:h*7/3, type:"clue"},

    /*{txt:"INSTRUCTIONS\nConnect all 5 hints to the mystery!", x:w, y:h*1/3-10, type:"instruction"}*/
  ];

  window[this_board].linesList = [
    {start:0,end:1}
  ];

  // Will be filled with created elements, useful for visually sorting them
  window[this_board].created_pins = [];
  window[this_board].created_notes = [];
  window[this_board].created_lines = [];
  window[this_board].reticule = {};

  window[this_board].init_board = function()
  {
    // Sets canvas to fill all the overlay
    var html_canvas = document.getElementById(`${this_board+"_cvs"}`);
    var parent = document.getElementById(`${this_board+"_overlay"}`);
    html_canvas.width = parent.offsetWidth;
    html_canvas.height = parent.offsetHeight;

  var canvas = this.canvas = new fabric.Canvas(`${this_board+"_cvs"}`, {
  selection: false,
  preserveObjectStacking: true, // important to prevent object from changing layers when selected or moved
  });

  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';

  var settings = {};
  settings.maxDezoom = 0.5;
  settings.maxZoom = 2;
  settings.noteWidth = 120;
  settings.noteHeight = 120;
  settings.notePadding = 10;
  settings.pinRadius = 12;
  settings.fontSize = 18;
  settings.maxPanX = canvas.getWidth()/settings.maxDezoom;
  settings.maxPanY = canvas.getHeight()/settings.maxDezoom;
  settings.gridspacing = 150;
  settings.gridOffset = 30;
  settings.noteColors = {
    "clue":"#FEFF9C",
    "question":"#6DCFF6",
    "picture":"white",
    "instruction":"white",
    "front-hint":"#FEFF9C",
  };

  settings.lineColor = "red";
  settings.gridColor = "#281918";


  /*
    lines are directed: they begin at a specific note, and enf at another
    when moving a note, they must update the lines if they're at the end of a line
    or a at their start

  */

  function makeNote(external_id, text, left, top, pin, type, fontSize)
  {
    var rect = new fabric.Rect({
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      fill: settings.noteColors[type],
      angle:6,
      stroke:"black",
      strokeWidth: 1,
    });

    var textObject = new fabric.Textbox(text, {
      left: left,
      top: top,
     width:settings.noteWidth-settings.notePadding/2,
     fontFamily:"Caveat-Regular",
     fontSize: fontSize,
     textAlign:"center",
     angle:3,
     fill: '#000000'
    });

  var group = new fabric.Group([rect, textObject],
    {
      external_id:external_id,
      object_type:"note",
      note_type:type,
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      pin:pin,

    });

    group.hasControls = group.hasBorders = false;

    return group;
  }

  function makePicture(external_id, text, left, top, pin, src, fontSize)
  {
    var rect = new fabric.Rect({
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      fill: settings.noteColors["picture"],
    });

    var textObject = new fabric.Textbox(text, {
     left: left,
     top: top+settings.noteHeight/2+settings.pinRadius-fontSize-2,
     width:settings.noteWidth-settings.notePadding/2,
     textAlign:"center",
     fontFamily:"Caveat-Regular",
     fontSize: fontSize,
     fill: '#000000'
    });

    var image = new fabric.Image(window._MediaCache[src], {
    left: left,
    top: top-settings.pinRadius/2,
    stroke:"black",
    strokeWidth:2,
    });

    // console.log(image,window._MediaCache[src])

  var group = new fabric.Group([rect, image, textObject],
    {
      external_id:external_id,
      object_type:"note",
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      pin:pin,
      angle:3
    });

    group.hasControls = group.hasBorders = false;

    return group;
  }

  function makeLine(start_pin_id, end_pin_id)
  {

    var start_pin = window[this_board].created_pins[start_pin_id];
    var end_pin = window[this_board].created_pins[end_pin_id];

    var line = new fabric.Line([start_pin.left, start_pin.top,end_pin.left, end_pin.top], {
      start_pin_id:start_pin_id,
      end_pin_id:end_pin_id,
      object_type:'line',
      fill: settings.lineColor,
      stroke: settings.lineColor,
      strokeWidth: 4,
      normalColor:settings.lineColor,
      darkColor:'#680000',
      perPixelTargetFind:true,
      targetFindTolerance:10,
      selectable: false,
      evented: true,
      hoverCursor:"pointer",
    });

      line.hasControls = line.hasBorders = false;


      start_pin.addLine(start_pin, line, "start");
      end_pin.addLine(end_pin, line, "end");

      return line;
  }

  function makePin(external_id, x, y)
  {
    var pin = new fabric.Circle({
      external_id:external_id,
        left: x,
        top: y,
        object_type:'pin',
        strokeWidth: 5,
        radius: settings.pinRadius,
        fill: '#fff',
        stroke: '#666',
        lines_start:[],
        lines_end:[],
        hoverCursor:'pointer',
        selectable: false,
        evented: true,
      });

      pin.movePin = function(pin,x,y)
      {

        for(i in pin.lines_start)
        {
          pin.lines_start[i].set({x1:x,y1:y});
          pin.lines_start[i].setCoords();
        }
        for(i in pin.lines_end)
        {
          pin.lines_end[i].set({x2:x,y2:y});
          pin.lines_end[i].setCoords();
        }

        pin.set({left:x, top:y});
        pin.setCoords();
      }

      pin.addLine = function(pin, line, edge_type)
      {
        if(edge_type == "start")
        {
          pin.lines_start.push(line);
        }else if(edge_type == "end")
        {
          pin.lines_end.push(line);
        }

      }


      pin.hasControls = pin.hasBorders = false;
    return pin;
  }

  function makeGridline(start_X, start_Y, end_X, end_Y)
  {

    var line = new fabric.Line([start_X, start_Y, end_X, end_Y], {
      object_type:'gridline',
      fill: settings.gridColor,
      stroke: settings.gridColor,
      strokeDashArray: [5, 10],
      strokeWidth: 2,
      selectable: false,
      evented: false
    });

      line.hasControls = line.hasBorders = false;

      return line;
  }


  window[this_board].add_note = function(note_data)
  {

    // Do not add a note with the exact same text
    var notes_txt = window[this_board].notesList.map(note => note.txt);
    if(notes_txt.indexOf(note_data.txt) > -1)
    {

      return false;
    }

    // randomzie position if doesn't have one or find empty space?
    note_data.x = note_data.x || window.randint(settings.noteWidth, canvas.width-settings.noteWidth);
    note_data.y = note_data.y || window.randint(settings.noteHeight, canvas.height-settings.noteHeight);
    note_data.fontSize = note_data.fontSize || settings.fontSize

    var id = window[this_board].notesList.length;
      // id should be the current length of notesList, to add at the end
    createNote(id, note_data, canvas);
    window[this_board].notesList.push(note_data);
    // add note to note list
    resortAllElements(canvas);
  }


  function createNote(i, note_data, canvas) // Create notes of all types and add tthem to the board
  {
    var pin = makePin(i, note_data.x, note_data.y-settings.noteHeight/2);

    if(note_data.type == "picture")
    {
      var note = makePicture(i, note_data.txt, note_data.x, note_data.y, pin, note_data.src, note_data.fontSize);
    }
    else
    {
      var note = makeNote(i, note_data.txt, note_data.x, note_data.y, pin, note_data.type, note_data.fontSize);
    }

    window[this_board].created_notes.push(note);
    window[this_board].created_pins.push(pin);


    canvas.add(note);
    canvas.add(pin);



  }

  function makeReticule()
  {

      var line = new fabric.Line([0,0,0,0], {
        object_type:'line',
        stroke: settings.lineColor,
        strokeDashArray: [5, 5],
        strokeWidth: 5,
        selectable: false,
        evented:false,
        opacity:0,
      });

      var visor = new fabric.Circle({
          left: 0,
          top: 0,
          object_type:'visor',
          strokeWidth: 5,
          radius: 12,
          stroke: settings.lineColor,
          fill:'transparent',
          selectable: false,
          evented:false,
          opacity:0,
        });


      var reticule =
        {
          start_pin:null,
          visor:visor,
          line:line,
          active:false,
        };

        reticule.moveVisor = function(reticule, x, y)
        {
          reticule.visor.set({left:x, top:y});
          reticule.visor.setCoords();
          reticule.line.set({x2:x, y2:y});
          reticule.line.setCoords();
        }

        reticule.addToCanvas = function(canvas, reticule)
        {
          canvas.add(reticule.line);
          canvas.add(reticule.visor);
        }

        reticule.hide = function(reticule)
        {
          reticule.visor.opacity = 0;
          reticule.line.opacity = 0;
          reticule.active = false;
        }

        reticule.show = function(reticule)
        {
          reticule.visor.opacity = 1;
          reticule.line.opacity = 1;
          reticule.active = true;
        }

        reticule.startFromPin = function(reticule, start_pin)
        {
          reticule.start_pin = start_pin;
          reticule.line.set({x1:start_pin.left, y1:start_pin.top});
          reticule.line.setCoords();
          reticule.moveVisor(reticule, start_pin.left, start_pin.top);
        }

        return reticule;
  }


    //Create Gridlines

    for(var y = 0; y < settings.maxPanY/settings.gridspacing; y++)
    {
      var gridline = makeGridline(0,y*settings.gridspacing+settings.gridOffset, settings.maxPanX, y*settings.gridspacing+settings.gridOffset);
      canvas.add(gridline);
    }

    for(var x = 0; x < settings.maxPanX/settings.gridspacing; x++)
    {
      var gridline = makeGridline(x*settings.gridspacing+settings.gridOffset,0, x*settings.gridspacing+settings.gridOffset,  settings.maxPanY);
      canvas.add(gridline);
    }

    // Create notes, remember their pins, add them
    for(var i = 0; i < window[this_board].notesList.length; i++)
    {
      var note_data = window[this_board].notesList[i];

      note_data.x = note_data.x || window.randint(settings.noteWidth, canvas.width-settings.noteWidth);
      note_data.y = note_data.y || window.randint(settings.noteHeight, canvas.height-settings.noteHeight);
      note_data.fontSize = note_data.fontSize || settings.fontSize


      createNote(i, note_data, canvas)

    }

    // Create lines
    for(var i = 0; i < window[this_board].linesList.length;i++)
    {
      var start_pin_id = window[this_board].linesList[i].start;
      var end_pin_id = window[this_board].linesList[i].end;
      var line = makeLine(start_pin_id, end_pin_id);

      window[this_board].created_lines.push(line);
      canvas.add(line);
    }

    //Add reticule

    window[this_board].reticule = makeReticule();
    var reticule = window[this_board].reticule;
    window[this_board].reticule.addToCanvas(canvas, window[this_board].reticule);

    resortAllElements(canvas);

  canvas.on('object:moving', function(e)
  {
    var p = e.target;

    if(p.left < p.width || p.left > settings.maxPanX - p.width)
    {
      p.left = Math.min(Math.max(p.width, p.left), settings.maxPanX - p.width);
      p.setCoords();
    }

    if(p.top < p.height || p.top > settings.maxPanY - p.height)
    {
      p.top = Math.min(Math.max(p.height, p.top), settings.maxPanY - p.height);
      p.setCoords();
    }


    if(p && p.object_type == 'note')
    {
      p.pin.movePin(p.pin,p.left, p.top-settings.noteHeight/2)
      // Updates data external strucure about post-its
      // Coordinates change
      window[this_board].notesList[p.external_id].x = p.left;
      window[this_board].notesList[p.external_id].y = p.top;

      canvas.requestRenderAll();
    }


    e.e.preventDefault();
    e.e.stopPropagation();


  });


  // Move reticule
  canvas.on('mouse:move', function(e)
  {

    if(window[this_board].reticule.active)
    {
      var pointer = canvas.getPointer(e);
      window[this_board].reticule.moveVisor(window[this_board].reticule, pointer.x, pointer.y);
      canvas.requestRenderAll();
    }

  });


  canvas.on('mouse:down', function(e)
  {
    var p = e.target;
    if(p && p.object_type == 'pin')
    {

      // Start reticule line if not already active
      if(!window[this_board].reticule.active)
      {
        window[this_board].reticule.startFromPin(window[this_board].reticule, p);
        window[this_board].reticule.show(window[this_board].reticule);
      }
      else // Create new line
      {
        var start_pin_id = window[this_board].reticule.start_pin.external_id;
        var end_pin_id = p.external_id;

        // Checks: do not add a line that already exists
        // start and end should be different

        var existence_check = true;
        for(var i in window[this_board].linesList)
        {
          var a = window[this_board].linesList[i].start;
          var b = window[this_board].linesList[i].end;
          if( (a == start_pin_id && b == end_pin_id) || ((b == start_pin_id && a == end_pin_id)) )
          {
            existence_check = false;
          }
        }

        if(existence_check && start_pin_id != end_pin_id)
        {
          window[this_board].linesList.push({start:start_pin_id, end:end_pin_id});

          var line = makeLine(start_pin_id, end_pin_id);
          window[this_board].created_lines.push(line);
          canvas.add(line);
          window[this_board].reticule.hide(reticule);
          resortAllElements(canvas);

          madeLineEvent(start_pin_id, end_pin_id);

        }

      }
    }
    else if (p && p.object_type == "line")
    {
        // Remove line from data structure and canvas

      var remove_index = null;
      for(var i =0; i < window[this_board].linesList.length; i++)
      {
        var a = window[this_board].linesList[i].start;
        var b = window[this_board].linesList[i].end;
        if( (a == p.start_pin_id && b == p.end_pin_id) || ((b == p.start_pin_id && a == p.end_pin_id)) )
        {
          remove_index = i;
        }
      }
      if(remove_index !== null)
      {
        window[this_board].linesList.splice(remove_index, 1);
      }
      else
      {
        console.log("line_error", p.start_pin_id, p.end_pin_id)
      }

      canvas.remove(p);

    }

    // Cancel reticule if click in empty space
    else if(!p && window[this_board].reticule.active)
    {
      window[this_board].reticule.hide(reticule);
      resortAllElements(canvas);
    }


  });

  // Line color hovering
  canvas.on('mouse:over',function(e)
  {
    var p = e.target;
    if(p && p.object_type == "line")
    {
      p.set({stroke:p.darkColor});
      canvas.requestRenderAll();
    }
  })

  canvas.on('mouse:out',function(e)
  {
    var p = e.target;
    if(p && p.object_type == "line")
    {
      p.set({stroke:p.normalColor});
      canvas.requestRenderAll();
    }
  })


  // Sort z index: keep the one for notes and lines, then reticule line, then pins, then reticule visor
  function resortAllElements(canvas)
  {

      canvas.bringToFront(window[this_board].reticule.line);
      for(var j in window[this_board].created_pins)
      {
        canvas.bringToFront(window[this_board].created_pins[j]);
      }


      // Bring front notes to front
      for(var j in window[this_board].created_notes)
      {
        var note = window[this_board].created_notes[j];
        if(note.note_type.indexOf("front") != -1)
        {
          canvas.bringToFront(note);
          canvas.bringToFront(note.pin);
        }
      }


      canvas.bringToFront(window[this_board].reticule.visor);

  }
    canvas.requestRenderAll();



  // Zoom and pan events
    canvas.on('mouse:wheel', function(opt) {
      var delta = opt.e.deltaY;
      var zoom = canvas.getZoom();
      zoom *= 0.999 ** delta;
      if (zoom > settings.maxZoom) zoom = settings.maxZoom;
      if (zoom < settings.maxDezoom) zoom = settings.maxDezoom;
      canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
      opt.e.preventDefault();
      opt.e.stopPropagation();
      var vpt = this.viewportTransform;
      // if (zoom <= settings.maxDezoom) {
      //   vpt[4] = 0 - settings.maxPanX * zoom / 2;
      //   vpt[5] = 0 - settings.maxPanY * zoom / 2;
      // } else {
        if (vpt[4] >= 0) {
          vpt[4] = 0;
        } else if (vpt[4] < canvas.getWidth() - settings.maxPanX * zoom) {
          vpt[4] = canvas.getWidth() - settings.maxPanX * zoom;
        }
        if (vpt[5] >= 0) {
          vpt[5] = 0;
        } else if (vpt[5] < canvas.getHeight() - settings.maxPanY * zoom) {
          vpt[5] = canvas.getHeight() - settings.maxPanY * zoom;
        }
      //}

      canvas.requestRenderAll();

    });

    canvas.on('mouse:down', function(opt) {
      var evt = opt.e;

      if(!opt.target) // Do not dragging if moving an object
      {
        this.isDragging = true;
        this.selection = false;
        this.lastPosX = evt.clientX;
        this.lastPosY = evt.clientY;
      }

    });
    canvas.on('mouse:move', function(opt) {
      if (this.isDragging) {
        var e = opt.e;
        var zoom = canvas.getZoom();
        var vpt = this.viewportTransform;
        // if (zoom <= settings.maxDezoom) {
        //   vpt[4] = 0 - settings.maxPanX * zoom / 2;
        //   vpt[5] = 0 - settings.maxPanY * zoom / 2;
        //} else {
          vpt[4] += e.clientX - this.lastPosX;
          vpt[5] += e.clientY - this.lastPosY;
          if (vpt[4] >= 0) {
            vpt[4] = 0;
          } else if (vpt[4] < canvas.getWidth() - settings.maxPanX * zoom) {
            vpt[4] = canvas.getWidth() - settings.maxPanX * zoom;
          }
          if (vpt[5] >= 0) {
            vpt[5] = 0;
          } else if (vpt[5] < canvas.getHeight() - settings.maxPanY * zoom) {
            vpt[5] = canvas.getHeight() - settings.maxPanY * zoom;
          }
        //}

        this.lastPosX = e.clientX;
        this.lastPosY = e.clientY;

        canvas.requestRenderAll();
      }
    });
    canvas.on('mouse:up', function(opt) {
      // on mouse up we want to recalculate new interaction
      // for all objects, so we call setViewportTransform
      this.setViewportTransform(this.viewportTransform);
      this.isDragging = false;
      canvas.requestRenderAll();
    });


  function madeLineEvent(start, end)
  {
    // CHeck if all 5 hints are connected to the blue mystery not
    // Highly dependent on notes ids. supposes they are fixed and go from 1 to 5
    var pairs = window[this_board].created_lines.map(line => [Math.min(line.start_pin_id, line.end_pin_id), Math.max(line.start_pin_id, line.end_pin_id)]);
    var sorted_hints = pairs.filter(pair => pair[0] == 0).map(pair => pair[1]).sort();
    var unique_hints = [...new Set(sorted_hints)];
    if(unique_hints.join("").indexOf("12345") != -1)
    {
      // all hints are connected!

      instructions.text = "WELL DONE!\nNow you know how to use the conspiracy board. Use it to gather clues and mysteries!\n(Close the board by tugging the handle again.)";
      window[this_board].clearZoomPan();
      window.pullcord.setTutorialPhase(2);
      window.PlaySound("jingle");
    }

  }


  window[this_board].clearZoomPan = function()
  {

    const animation_duration = 1800;

    // Easing function
    function easeInOut(t) {return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1};

    // Interpolation between those two transforms, easing it for each value
    // Target Transform = canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
    var initial_transform = canvas.viewportTransform;
    var target_transform = [1, 0, 0, 1, 0, 0];

    function animationCall(normalised_time)
    {
      var current_transform = [];
      for(var i in target_transform)
      {
        var initial = initial_transform[i]
        var target = target_transform[i];
        var current = initial + (target - initial) * easeInOut(normalised_time); // time must be normalised between 0 and 1;
        current_transform[i] = current;
      }

      // Set transform, render
      canvas.viewportTransform = current_transform;
      canvas.renderAll();
    }


    // ANimation using requestAnimationFrame instead of setInterval
    let start = null, previousTimeStamp;
    let done = false;
    function stepAnimation(timestamp)
    {
      if(start === null)
      {
        start = timestamp;
      }
      const elapsed = timestamp - start;

      if(previousTimeStamp !== timestamp)
      {
        animationCall(elapsed/animation_duration);
      }

      if(elapsed < animation_duration)
      {
        window.requestAnimationFrame(stepAnimation);
      }
    }

    window.requestAnimationFrame(stepAnimation);
  }

  /* Run at init*/

  var instructions_txt = "INSTRUCTIONS\nConnect all 5 hints to the mystery in the middle";

  var instructions = new fabric.Textbox(instructions_txt, {
    left: canvas.getWidth()/2,
    top: 60,
   width:canvas.getWidth()*0.9,
   fontFamily:"Caveat-Regular",
   fontSize: 24,
   textAlign:"center",
   angle:0,
   fill: '#FFFFFF'
  });

  instructions.hasControls = instructions.hasBorders = false;
  canvas.add(instructions);


  };

})();
