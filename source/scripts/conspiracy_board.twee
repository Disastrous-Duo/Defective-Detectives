:: Conspiracy Board [script]

(function(){ // self-containing function for scope purpose

// To create a new board,
//1.copy-paste this file, change the Twine scene name
//2.change the this_board name variable
//3. call window[this_board] init function at startup

let this_board = "conspiracy_board";
window[this_board] = {};



// Creates the HTML elements for the board
let genButton = (name, functionName) => `<input type="button" value="${name}" onclick="${functionName}();" />`;

let html_conspiracy_board =
`
<div id="${this_board+"_overlay"}" class="boards_overlay">
<canvas id="${this_board+"_cvs"}"></canvas>
</div>
`;


// Creates debug buttons
//$(genButton("Toggle Board","window['"+this_board+"'].toggle_board")).insertAfter("#story-author");

// Add board to HTML
$(html_conspiracy_board).insertBefore("#passages");

window[this_board].conspiracy_board_toggled = false;


window[this_board].toggle_board = function()
{
  window[this_board].conspiracy_board_toggled = !window[this_board].conspiracy_board_toggled;
  if(window[this_board].conspiracy_board_toggled)
  {
    $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_up");
    $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_down");
  }
  else
  {
    $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_down");
    $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_up");
  }
};




////////////////////


// Temporary data for debug purposes

// sizes for the canvas that is about to be resized
// var parent = document.getElementById(`${this_board+"_overlay"}`);
// var w = Math.round(parent.offsetWidth/2);
// var h = Math.round(parent.offsetHeight/2);

  window[this_board].notesList = [
  ];

  window[this_board].linesList = [
    //{start:1,end:2}
  ];

  // Will be filled with created elements, useful for visually sorting them
  window[this_board].created_pins = [];
  window[this_board].created_notes = [];
  window[this_board].created_lines = [];
  window[this_board].reticule = {};

  window[this_board].init_board = function()
  {
    // Sets canvas to fill all the overlay
    var html_canvas = document.getElementById(`${this_board+"_cvs"}`);
    var parent = $(`#${this_board+"_overlay"}`);


    // html_canvas.width = parent.offsetWidth;
    // html_canvas.height = parent.offsetHeight;

    var calc_width =  $("#story").width()-$("#ui-bar-body").width();
    var calc_height = $("body").height()*0.9;



    parent.width(calc_width);
    parent.height(calc_height);
    html_canvas.width = calc_width;
    html_canvas.height = calc_height;


  var canvas = this.canvas = new fabric.Canvas(`${this_board+"_cvs"}`, { selection: false,
  preserveObjectStacking: true // important to prevent object from changing layers when selected or moved
  });

  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';

  var settings = {};
  settings.maxDezoom = 0.5;
  settings.maxZoom = 2;
  settings.noteWidth = 120;
  settings.noteHeight = 120;
  settings.notePadding = 12;
  settings.pinRadius = 12;
  settings.fontSize = 18;
  settings.maxPanX = canvas.getWidth()/settings.maxDezoom;
  settings.maxPanY = canvas.getHeight()/settings.maxDezoom;
  settings.gridspacing = 150;
  settings.gridOffset = 30;
  settings.noteColors = {
    "clue":"#FEFF9C",
    "question":"#6DCFF6",
    "picture":"white",
    "instruction":"white",
    "front-clue":"#FEFF9C",
  };

  settings.lineColor = "red";
  settings.gridColor = "#281918";
  settings.newNoteBorderColor = "red";
  settings.newNoteStrokeWidth = 3;
  settings.normalNoteBorderColor = "black";
  settings.normalStrokeWidth = 1;


  /*
    lines are directed: they begin at a specific note, and end at another
    when moving a note, they must update the lines if they're at the end of a line
    or a at their start

  */

  function makeNote(external_id, text, left, top, pin, type, fontSize)
  {
    var rect = new fabric.Rect({
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      fill: settings.noteColors[type],
      angle:6,
      stroke:settings.newNoteBorderColor,
      strokeWidth: settings.newNoteStrokeWidth,
    });

    var textObject = new fabric.Textbox(text, {
      left: left,
      top: top,
     width:settings.noteWidth-settings.notePadding/2,
     fontFamily:"Caveat-Regular",
     fontSize: fontSize,
     textAlign:"center",
     angle:3,
     fill: '#000000'
    });

  var group = new fabric.Group([rect, textObject],
    {
      external_id:external_id,
      object_type:"note",
      note_type:type,
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      pin:pin,
      rect:rect,
      textObject:textObject

    });

    group.hasControls = group.hasBorders = false;

    return group;
  }

  function makePicture(external_id, text, left, top, pin, src, fontSize)
  {
    var rect = new fabric.Rect({
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      fill: settings.noteColors["picture"],
      stroke:settings.newNoteBorderColor,
      strokeWidth: settings.newNoteStrokeWidth,
    });

    var textObject = new fabric.Textbox(text, {
     left: left,
     top: top+settings.noteHeight/2+settings.pinRadius-fontSize-2,
     width:settings.noteWidth-settings.notePadding/2,
     textAlign:"center",
     fontFamily:"Caveat-Regular",
     fontSize: fontSize,
     fill: '#000000'
    });

    var image = new fabric.Image(window._MediaCache[src], {
    left: left,
    top: top-settings.pinRadius/2,
    stroke:"black",
    strokeWidth:2,
    });

    console.log(image,window._MediaCache[src])

  var group = new fabric.Group([rect, image, textObject],
    {
      external_id:external_id,
      object_type:"note",
      left: left,
      top: top,
      width:settings.noteWidth,
      height:settings.noteHeight,
      rect:rect,
      pin:pin,
      angle:3
    });

    group.hasControls = group.hasBorders = false;

    return group;
  }

  function makeLine(start_pin_id, end_pin_id)
  {

    var start_pin = window[this_board].created_pins[start_pin_id];
    var end_pin = window[this_board].created_pins[end_pin_id];

    var line = new fabric.Line([start_pin.left, start_pin.top,end_pin.left, end_pin.top], {
      start_pin_id:start_pin_id,
      end_pin_id:end_pin_id,
      object_type:'line',
      fill: settings.lineColor,
      stroke: settings.lineColor,
      strokeWidth: 4,
      normalColor:settings.lineColor,
      darkColor:'#680000',
      perPixelTargetFind:true,
      targetFindTolerance:10,
      selectable: false,
      evented: true,
      hoverCursor:"pointer",
    });

      line.hasControls = line.hasBorders = false;


      start_pin.addLine(start_pin, line, "start");
      end_pin.addLine(end_pin, line, "end");

      return line;
  }

  function makePin(external_id, x, y)
  {
    var pin = new fabric.Circle({
      external_id:external_id,
        left: x,
        top: y,
        object_type:'pin',
        strokeWidth: 5,
        radius: settings.pinRadius,
        fill: '#fff',
        stroke: '#666',
        lines_start:[],
        lines_end:[],
        hoverCursor:'pointer',
        selectable: false,
        evented: true,
      });

      pin.movePin = function(pin,x,y)
      {

        for(i in pin.lines_start)
        {
          pin.lines_start[i].set({x1:x,y1:y});
          pin.lines_start[i].setCoords();
        }
        for(i in pin.lines_end)
        {
          pin.lines_end[i].set({x2:x,y2:y});
          pin.lines_end[i].setCoords();
        }

        pin.set({left:x, top:y});
        pin.setCoords();
      }

      pin.addLine = function(pin, line, edge_type)
      {
        if(edge_type == "start")
        {
          pin.lines_start.push(line);
        }else if(edge_type == "end")
        {
          pin.lines_end.push(line);
        }

      }


      pin.hasControls = pin.hasBorders = false;
    return pin;
  }

  function makeGridline(start_X, start_Y, end_X, end_Y)
  {

    var line = new fabric.Line([start_X, start_Y, end_X, end_Y], {
      object_type:'gridline',
      fill: settings.gridColor,
      stroke: settings.gridColor,
      strokeDashArray: [5, 10],
      strokeWidth: 2,
      selectable: false,
      evented: false
    });

      line.hasControls = line.hasBorders = false;

      return line;
  }


  window[this_board].add_note = function(note_data)
  {

    // Do not add a note with the exact same text
    var notes_id = window[this_board].notesList.map(note => note.id);
    if(notes_id.indexOf(note_data.id) > -1)
    {

      return false;
    }

    // randomzie position if doesn't have one or find empty space?
    note_data.x = note_data.x || window.randint(settings.noteWidth, canvas.width-settings.noteWidth);
    note_data.y = note_data.y || window.randint(settings.noteHeight, canvas.height-settings.noteHeight);
    note_data.fontSize = note_data.fontSize || settings.fontSize

    var id = window[this_board].notesList.length;
      // id should be the current length of notesList, to add at the end
    createNote(id, note_data, canvas);
    window[this_board].notesList.push(note_data);
    // add note to note list
    resortAllElements(canvas);
  }


  function createNote(i, note_data, canvas) // Create notes of all types and add tthem to the board
  {
    var pin = makePin(i, note_data.x, note_data.y-settings.noteHeight/2);

    if(note_data.type == "picture")
    {
      var note = makePicture(i, note_data.txt, note_data.x, note_data.y, pin, note_data.src, note_data.fontSize);
    }
    else
    {
      var note = makeNote(i, note_data.txt, note_data.x, note_data.y, pin, note_data.type, note_data.fontSize);
    }

    window[this_board].created_notes.push(note);
    window[this_board].created_pins.push(pin);


    canvas.add(note);
    canvas.add(pin);

    // If the instructions are still there, remove them
    if(instructions)
    {
      canvas.remove(instructions);
      instructions = false;
    }
  }

  function makeReticule()
  {

      var line = new fabric.Line([0,0,0,0], {
        object_type:'line',
        stroke: settings.lineColor,
        strokeDashArray: [5, 5],
        strokeWidth: 5,
        selectable: false,
        evented:false,
        opacity:0,
      });

      var visor = new fabric.Circle({
          left: 0,
          top: 0,
          object_type:'visor',
          strokeWidth: 5,
          radius: 12,
          stroke: settings.lineColor,
          fill:'transparent',
          selectable: false,
          evented:false,
          opacity:0,
        });


      var reticule =
        {
          start_pin:null,
          visor:visor,
          line:line,
          active:false,
        };

        reticule.moveVisor = function(reticule, x, y)
        {
          reticule.visor.set({left:x, top:y});
          reticule.visor.setCoords();
          reticule.line.set({x2:x, y2:y});
          reticule.line.setCoords();
        }

        reticule.addToCanvas = function(canvas, reticule)
        {
          canvas.add(reticule.line);
          canvas.add(reticule.visor);
        }

        reticule.hide = function(reticule)
        {
          reticule.visor.opacity = 0;
          reticule.line.opacity = 0;
          reticule.active = false;
        }

        reticule.show = function(reticule)
        {
          reticule.visor.opacity = 1;
          reticule.line.opacity = 1;
          reticule.active = true;
        }

        reticule.startFromPin = function(reticule, start_pin)
        {
          reticule.start_pin = start_pin;
          reticule.line.set({x1:start_pin.left, y1:start_pin.top});
          reticule.line.setCoords();
          reticule.moveVisor(reticule, start_pin.left, start_pin.top);
        }

        return reticule;
  }


    //Create Gridlines

    for(var y = 0; y < settings.maxPanY/settings.gridspacing; y++)
    {
      var gridline = makeGridline(0,y*settings.gridspacing+settings.gridOffset, settings.maxPanX, y*settings.gridspacing+settings.gridOffset);
      canvas.add(gridline);
    }

    for(var x = 0; x < settings.maxPanX/settings.gridspacing; x++)
    {
      var gridline = makeGridline(x*settings.gridspacing+settings.gridOffset,0, x*settings.gridspacing+settings.gridOffset,  settings.maxPanY);
      canvas.add(gridline);
    }

    // Create notes, remember their pins, add them
    for(var i = 0; i < window[this_board].notesList.length; i++)
    {
      var note_data = window[this_board].notesList[i];

      note_data.x = note_data.x || window.randint(settings.noteWidth, canvas.width-settings.noteWidth);
      note_data.y = note_data.y || window.randint(settings.noteHeight, canvas.height-settings.noteHeight);
      note_data.fontSize = note_data.fontSize || settings.fontSize


      createNote(i, note_data, canvas)

    }

    // Create lines
    for(var i = 0; i < window[this_board].linesList.length;i++)
    {
      var start_pin_id = window[this_board].linesList[i].start;
      var end_pin_id = window[this_board].linesList[i].end;
      var line = makeLine(start_pin_id, end_pin_id);

      window[this_board].created_lines.push(line);
      canvas.add(line);
    }

    //Add reticule

    window[this_board].reticule = makeReticule();
    var reticule = window[this_board].reticule;
    window[this_board].reticule.addToCanvas(canvas, window[this_board].reticule);

    resortAllElements(canvas);

  canvas.on('object:moving', function(e)
  {
    var p = e.target;

    if(p.left < p.width || p.left > settings.maxPanX - p.width)
    {
      p.left = Math.min(Math.max(p.width, p.left), settings.maxPanX - p.width);
      p.setCoords();
    }

    if(p.top < p.height || p.top > settings.maxPanY - p.height)
    {
      p.top = Math.min(Math.max(p.height, p.top), settings.maxPanY - p.height);
      p.setCoords();
    }


    if(p && p.object_type == 'note')
    {

      //Set bordercolor to default -- effect where new post-its will be highlighted
      p.rect.set({stroke:settings.normalNoteBorderColor,strokeWidth:settings.normalStrokeWidth })

      //Move associated pin too
      p.pin.movePin(p.pin,p.left, p.top-settings.noteHeight/2)
      // Updates data external strucure about post-its
      // Coordinates change
      window[this_board].notesList[p.external_id].x = p.left;
      window[this_board].notesList[p.external_id].y = p.top;

      canvas.renderAll();
    }


    e.e.preventDefault();
    e.e.stopPropagation();


  });


  // Move reticule
  canvas.on('mouse:move', function(e)
  {

    if(window[this_board].reticule.active)
    {
      var pointer = canvas.getPointer(e);
      window[this_board].reticule.moveVisor(window[this_board].reticule, pointer.x, pointer.y);
      canvas.renderAll();
    }

  });


  canvas.on('mouse:down', function(e)
  {
    var p = e.target;
    if(p && p.object_type == 'pin')
    {

      // Start reticule line if not already active
      if(!window[this_board].reticule.active)
      {
        window[this_board].reticule.startFromPin(window[this_board].reticule, p);
        window[this_board].reticule.show(window[this_board].reticule);
      }
      else // Create new line
      {
        var start_pin_id = window[this_board].reticule.start_pin.external_id;
        var end_pin_id = p.external_id;

        // Checks: do not add a line that already exists
        // start and end should be different

        var existence_check = true;
        for(var i in window[this_board].linesList)
        {
          var a = window[this_board].linesList[i].start;
          var b = window[this_board].linesList[i].end;
          if( (a == start_pin_id && b == end_pin_id) || ((b == start_pin_id && a == end_pin_id)) )
          {
            existence_check = false;
          }
        }

        if(existence_check && start_pin_id != end_pin_id)
        {
          window[this_board].linesList.push({start:start_pin_id, end:end_pin_id});

          var line = makeLine(start_pin_id, end_pin_id);
          window[this_board].created_lines.push(line);
          canvas.add(line);
          window[this_board].reticule.hide(reticule);
          resortAllElements(canvas);

          madeLineEvent(start_pin_id, end_pin_id);

        }

      }
    }
    else if (p && p.object_type == "line")
    {
        // Remove line from data structure and canvas

      var remove_index = null;
      for(var i =0; i < window[this_board].linesList.length; i++)
      {
        var a = window[this_board].linesList[i].start;
        var b = window[this_board].linesList[i].end;
        if( (a == p.start_pin_id && b == p.end_pin_id) || ((b == p.start_pin_id && a == p.end_pin_id)) )
        {
          remove_index = i;
        }
      }
      if(remove_index !== null)
      {
        window[this_board].linesList.splice(remove_index, 1);
      }
      else
      {
        console.log("line_error", p.start_pin_id, p.end_pin_id)
      }

      canvas.remove(p);

    }

    // Cancel reticule if click in empty space
    else if(!p && window[this_board].reticule.active)
    {
      window[this_board].reticule.hide(reticule);
      resortAllElements(canvas);
    }


  });

  // Line color hovering
  canvas.on('mouse:over',function(e)
  {
    var p = e.target;
    if(p && p.object_type == "line")
    {
      p.set({stroke:p.darkColor});
      canvas.renderAll();
    }
  })

  canvas.on('mouse:out',function(e)
  {
    var p = e.target;
    if(p && p.object_type == "line")
    {
      p.set({stroke:p.normalColor});
      canvas.renderAll();
    }
  })


  // Sort z index: keep the one for notes and lines, then reticule line, then pins, then reticule visor
  function resortAllElements(canvas)
  {

      canvas.bringToFront(window[this_board].reticule.line);
      for(var j in window[this_board].created_pins)
      {
        canvas.bringToFront(window[this_board].created_pins[j]);
      }


      // Bring front notes to front
      for(var j in window[this_board].created_notes)
      {
        var note = window[this_board].created_notes[j];
        if(note.type.indexOf("front") != -1)
        {
          canvas.bringToFront(note);
          canvas.bringToFront(note.pin);
        }
      }


      canvas.bringToFront(window[this_board].reticule.visor);

  }
    canvas.renderAll();



  // Zoom and pan events
    canvas.on('mouse:wheel', function(opt) {
      var delta = opt.e.deltaY;
      var zoom = canvas.getZoom();
      zoom *= 0.999 ** delta;
      if (zoom > settings.maxZoom) zoom = settings.maxZoom;
      if (zoom < settings.maxDezoom) zoom = settings.maxDezoom;
      canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
      opt.e.preventDefault();
      opt.e.stopPropagation();
      var vpt = this.viewportTransform;
      // if (zoom <= settings.maxDezoom) {
      //   vpt[4] = 0 - settings.maxPanX * zoom / 2;
      //   vpt[5] = 0 - settings.maxPanY * zoom / 2;
      // } else {
        if (vpt[4] >= 0) {
          vpt[4] = 0;
        } else if (vpt[4] < canvas.getWidth() - settings.maxPanX * zoom) {
          vpt[4] = canvas.getWidth() - settings.maxPanX * zoom;
        }
        if (vpt[5] >= 0) {
          vpt[5] = 0;
        } else if (vpt[5] < canvas.getHeight() - settings.maxPanY * zoom) {
          vpt[5] = canvas.getHeight() - settings.maxPanY * zoom;
        }
      //}
    });

    canvas.on('mouse:down', function(opt) {
      var evt = opt.e;

      if(!opt.target) // Do not dragging if moving an object
      {
        this.isDragging = true;
        this.selection = false;
        this.lastPosX = evt.clientX;
        this.lastPosY = evt.clientY;
      }

    });
    canvas.on('mouse:move', function(opt) {
      if (this.isDragging) {
        var e = opt.e;
        var zoom = canvas.getZoom();
        var vpt = this.viewportTransform;
        // if (zoom <= settings.maxDezoom) {
        //   vpt[4] = 0 - settings.maxPanX * zoom / 2;
        //   vpt[5] = 0 - settings.maxPanY * zoom / 2;
        //} else {
          vpt[4] += e.clientX - this.lastPosX;
          vpt[5] += e.clientY - this.lastPosY;
          if (vpt[4] >= 0) {
            vpt[4] = 0;
          } else if (vpt[4] < canvas.getWidth() - settings.maxPanX * zoom) {
            vpt[4] = canvas.getWidth() - settings.maxPanX * zoom;
          }
          if (vpt[5] >= 0) {
            vpt[5] = 0;
          } else if (vpt[5] < canvas.getHeight() - settings.maxPanY * zoom) {
            vpt[5] = canvas.getHeight() - settings.maxPanY * zoom;
          }
        //}
        this.requestRenderAll();
        this.lastPosX = e.clientX;
        this.lastPosY = e.clientY;
      }
    });
    canvas.on('mouse:up', function(opt) {
      // on mouse up we want to recalculate new interaction
      // for all objects, so we call setViewportTransform
      this.setViewportTransform(this.viewportTransform);
      this.isDragging = false;
    });


    function madeLineEvent(start, end)
    {
      // Empty event for now

    }



    // Initialise the board with an event
    var instructions_txt = "Here's the CONSPIRACY BOARD.\n This is where all the clues and mysteries you have collected will go!";
    var instructions = new fabric.Textbox(instructions_txt, {
      left: canvas.getWidth()/2,
      top: canvas.getHeight()/2,
     width:canvas.getWidth()*0.9,
     fontFamily:"Caveat-Regular",
     fontSize: 24,
     textAlign:"center",
     angle:0,
     fill: '#FFFFFF'
    });

    instructions.hasControls = instructions.hasBorders = false;

    canvas.add(instructions);

  };

})();
