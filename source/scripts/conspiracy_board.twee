:: Conspiracy Board [script]

(function(){ // self-containing function for scope purpose

// To create a new board,
//1.copy-paste this file, change the Twine scene name
//2.change the this_board name variable
//3. call window[this_board] init function at startup

let this_board = "conspiracy_board"
window[this_board] = {};



// Creates the HTML elements for the board
let genButton = (name, functionName) => `<input type="button" value="${name}" onclick="${functionName}();" />`;

let html_conspiracy_board =
`
<div id="${this_board+"_overlay"}" class="boards_overlay">
<canvas id="${this_board+"_cvs"}"></canvas>
</div>
`;


// Creates debug buttons
$(genButton("Toggle Board","window['"+this_board+"'].toggle_board")).insertAfter("#story-author");
$(html_conspiracy_board).insertBefore("#passages");

window[this_board].conspiracy_board_toggled = false;


window[this_board].toggle_board = function()
{
  window[this_board].conspiracy_board_toggled = !window[this_board].conspiracy_board_toggled;
  if(window[this_board].conspiracy_board_toggled)
  {
    $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_up");
    $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_down");
  }
  else
  {
    $(`${"#"+this_board+"_overlay"}`).removeClass("conspiracy_board_down");
    $(`${"#"+this_board+"_overlay"}`).addClass("conspiracy_board_up");
  }
};




////////////////////


// Temporary data for debug purposes

window[this_board].notesList = [
  {txt:"Wallet stolen by a cat", x:120, y:150},
  {txt:"Cats bring items to Katty", x:100, y:380},
  {txt:"Who has the wallet?", x:300, y:100},
  {txt:"Who is the client?", x:360, y:300}

];

window[this_board].linesList = [
  //{start:1,end:2}
];

window[this_board].created_pins = []; // will be filled, and store line elements
window[this_board].reticule = {};

window[this_board].init_board = function()
{
  // Sets canvas to fill all the overlay
  var html_canvas = document.getElementById(`${this_board+"_cvs"}`);
  var parent = document.getElementById(`${this_board+"_overlay"}`);
  html_canvas.width = parent.offsetWidth;
  html_canvas.height = parent.offsetHeight;

var canvas = this.canvas = new fabric.Canvas(`${this_board+"_cvs"}`, { selection: false,
preserveObjectStacking: true // important to prevent object from changing layers when selected or moved
});

fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';

var settings = {};
settings.noteWidth = 100;
settings.noteHeight = 100;
settings.notePadding = 6;


/*
  lines are directed: they begin at a specific note, and enf at another
  when moving a note, they must update the lines if they're at the end of a line
  or a at their start

*/

function makeNote(external_id, text, left, top, pin)
{
  var rect = new fabric.Rect({
    left: left,
    top: top,
    width:settings.noteWidth,
    height:settings.noteHeight,
    fill: '#FEFF9C',
    angle:3,
  });

  var textObject = new fabric.Textbox(text, {
   left: left+settings.notePadding/2,
   top: top+settings.notePadding/2,
   width:settings.noteWidth-settings.notePadding/2,
   fontFamily:"Caveat",
   fontSize: 19,
   fill: '#000000'
  });

var group = new fabric.Group([rect, textObject],
  {
    external_id:external_id,
    object_type:"note",
    left: left,
    top: top,
    width:settings.noteWidth,
    height:settings.noteHeight,
    pin:pin,

  });

  group.hasControls = group.hasBorders = false;

  return group;
}

function makeLine(start_pin_id, end_pin_id)
{

  var start_pin = window[this_board].created_pins[start_pin_id];
  var end_pin = window[this_board].created_pins[end_pin_id];

  var line = new fabric.Line([start_pin.left, start_pin.top,end_pin.left, end_pin.top], {
    start_pin_id:start_pin_id,
    end_pin_id:end_pin_id,
    object_type:'line',
    fill: 'red',
    stroke: 'red',
    strokeWidth: 4,
    normalColor:'red',
    darkColor:'#680000',
    perPixelTargetFind:true,
    targetFindTolerance:10,
    selectable: false,
    evented: true,
    hoverCursor:"pointer",
  });

    line.hasControls = line.hasBorders = false;


    start_pin.addLine(start_pin, line, "start");
    end_pin.addLine(end_pin, line, "end");

    return line;
}

function makePin(external_id, x, y)
{
  var pin = new fabric.Circle({
    external_id:external_id,
      left: x,
      top: y,
      object_type:'pin',
      strokeWidth: 5,
      radius: 12,
      fill: '#fff',
      stroke: '#666',
      lines_start:[],
      lines_end:[],
      hoverCursor:'pointer',
      selectable: false,
      evented: true,
    });

    pin.movePin = function(pin,x,y)
    {

      for(i in pin.lines_start)
      {
        pin.lines_start[i].set({x1:x,y1:y});
        pin.lines_start[i].setCoords();
      }
      for(i in pin.lines_end)
      {
        pin.lines_end[i].set({x2:x,y2:y});
        pin.lines_end[i].setCoords();
      }

      pin.set({left:x, top:y});
      pin.setCoords();
    }

    pin.addLine = function(pin, line, edge_type)
    {
      if(edge_type == "start")
      {
        pin.lines_start.push(line);
      }else if(edge_type == "end")
      {
        pin.lines_end.push(line);
      }

    }

    pin.on('click',function(e)
  {
    alert("click");
  });


    pin.hasControls = pin.hasBorders = false;
  return pin;
}


window[this_board].add_note = function(note_txt)
{

  // Do not add a note with the exact same text
  var notes_txt = window[this_board].notesList.map(note => note.txt);
  if(notes_txt.indexOf(note_txt) > -1)
  {
    return false;
  }

  // randomzie position if doesn't have one or find empty space?
  var x = window.randint(0, canvas.width-settings.noteWidth);
  var y = window.randint(0, canvas.height-settings.noteHeight);
  var note = {txt:note_txt,x:x, y:y};

  var id = window[this_board].notesList.length;
    // id should be the current length of notesList, to add at the end
  createNote(id, note, canvas);
  window[this_board].notesList.push(note);
  // add note to note list
  resortAllElements(canvas);
}


function createNote(i, note, canvas)
{
  var pin = makePin(i, note.x, note.y-settings.noteHeight/2);
  var note = makeNote(i, note.txt, note.x, note.y, pin);

  //created_notes.push(note);
  window[this_board].created_pins.push(pin);

  canvas.add(note);
  canvas.add(pin);
}

function makeReticule()
{

    var line = new fabric.Line([0,0,0,0], {
      object_type:'line',
      stroke: 'red',
      strokeDashArray: [5, 5],
      strokeWidth: 5,
      selectable: false,
      evented:false,
      opacity:0,
    });

    var visor = new fabric.Circle({
        left: 0,
        top: 0,
        object_type:'visor',
        strokeWidth: 5,
        radius: 12,
        stroke: 'red',
        fill:'transparent',
        selectable: false,
        evented:false,
        opacity:0,
      });


    var reticule =
      {
        start_pin:null,
        visor:visor,
        line:line,
        active:false,
      };

      reticule.moveVisor = function(reticule, x, y)
      {
        reticule.visor.set({left:x, top:y});
        reticule.visor.setCoords();
        reticule.line.set({x2:x, y2:y});
        reticule.line.setCoords();
      }

      reticule.addToCanvas = function(canvas, reticule)
      {
        canvas.add(reticule.line);
        canvas.add(reticule.visor);
      }

      reticule.hide = function(reticule)
      {
        reticule.visor.opacity = 0;
        reticule.line.opacity = 0;
        reticule.active = false;
      }

      reticule.show = function(reticule)
      {
        reticule.visor.opacity = 1;
        reticule.line.opacity = 1;
        reticule.active = true;
      }

      reticule.startFromPin = function(reticule, start_pin)
      {
        reticule.start_pin = start_pin;
        reticule.line.set({x1:start_pin.left, y1:start_pin.top});
        reticule.line.setCoords();
        reticule.moveVisor(reticule, start_pin.left, start_pin.top);
      }

      return reticule;
}
  // Create notes, remember their pins, add them
  for(var i = 0; i < window[this_board].notesList.length; i++)
  {
    var note = window[this_board].notesList[i];
    createNote(i, note, canvas)

  }

  // Create lines
  for(var i = 0; i < window[this_board].linesList.length;i++)
  {
    var start_pin_id = window[this_board].linesList[i].start;
    var end_pin_id = window[this_board].linesList[i].end;
    var line = makeLine(start_pin_id, end_pin_id);

    canvas.add(line);
  }

  //Add reticule

  window[this_board].reticule = makeReticule();
  var reticule = window[this_board].reticule;
  //reticule.startFromPin(created_pins[2]);
  //reticule.show(reticule);
  window[this_board].reticule.addToCanvas(canvas, window[this_board].reticule);


canvas.on('object:moving', function(e)
{
  var p = e.target;
  if(p && p.object_type == 'note')
  {
    p.pin.movePin(p.pin,p.left, p.top-settings.noteHeight/2)
    // Updates data external strucure about post-its
    // Coordinates change
    window[this_board].notesList[p.external_id].x = p.left;
    window[this_board].notesList[p.external_id].y = p.top;

    canvas.renderAll();
  }



});


// Move reticule
canvas.on('mouse:move', function(e)
{

  if(window[this_board].reticule.active)
  {
    window[this_board].reticule.moveVisor(window[this_board].reticule, e.pointer.x, e.pointer.y);
    canvas.renderAll();
  }

});


canvas.on('mouse:down', function(e)
{
  var p = e.target;
  if(p && p.object_type == 'pin')
  {

    // Start reticule line if not already active
    if(!window[this_board].reticule.active)
    {
      window[this_board].reticule.startFromPin(window[this_board].reticule, p);
      window[this_board].reticule.show(window[this_board].reticule);
    }
    else // Create new line
    {
      var start_pin_id = window[this_board].reticule.start_pin.external_id;
      var end_pin_id = p.external_id;

      // Checks: do not add a line that already exists
      // start and end should be different

      var existence_check = true;
      for(var i in window[this_board].linesList)
      {
        var a = window[this_board].linesList[i].start;
        var b = window[this_board].linesList[i].end;
        if( (a == start_pin_id && b == end_pin_id) || ((b == start_pin_id && a == end_pin_id)) )
        {
          existence_check = false;
        }
      }

      if(existence_check && start_pin_id != end_pin_id)
      {
        window[this_board].linesList.push({start:start_pin_id, end:end_pin_id});

        var line = makeLine(start_pin_id, end_pin_id);
        canvas.add(line);
        window[this_board].reticule.hide(reticule);
        resortAllElements(canvas);
      }

    }
  }
  else if (p && p.object_type == "line")
  {
      // Remove line from data structure and canvas

    var remove_index = null;
    for(var i =0; i < window[this_board].linesList.length; i++)
    {
      var a = window[this_board].linesList[i].start;
      var b = window[this_board].linesList[i].end;
      if( (a == p.start_pin_id && b == p.end_pin_id) || ((b == p.start_pin_id && a == p.end_pin_id)) )
      {
        remove_index = i;
      }
    }
    if(remove_index !== null)
    {
      window[this_board].linesList.splice(remove_index, 1);
    }
    else
    {
      console.log("line_error", p.start_pin_id, p.end_pin_id)
    }

    canvas.remove(p);

  }

  // Cancel reticule if click in empty space
  else if(!p && window[this_board].reticule.active)
  {
    window[this_board].reticule.hide(reticule);
    resortAllElements(canvas);
  }


});

// Line color hovering
canvas.on('mouse:over',function(e)
{
  var p = e.target;
  if(p && p.object_type == "line")
  {
    p.set({stroke:p.darkColor});
    canvas.renderAll();
  }
})

canvas.on('mouse:out',function(e)
{
  var p = e.target;
  if(p && p.object_type == "line")
  {
    p.set({stroke:p.normalColor});
    canvas.renderAll();
  }
})


// Sort z index: keep the one for notes and lines, then reticule line, then pins, then reticule visor
function resortAllElements(canvas)
{
  canvas.bringToFront(window[this_board].reticule.line);
  for(var j in window[this_board].created_pins)
  {
    canvas.bringToFront(window[this_board].created_pins[j]);
  }
  canvas.bringToFront(window[this_board].reticule.visor);
}
  canvas.renderAll();

}

})();
