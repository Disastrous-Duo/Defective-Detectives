:: Conspiracy Board [script]


// Creates the HTML element

let genButton = (name, functionName) => `<input type="button" value="${name}" onclick="${functionName}();" />`;

let html_conspiracy_board =
`
<div id="conspiracy_board_overlay">
<canvas id="cvs_conspiracy_board"></canvas>
</div>
`;


// Creates debug buttons
$(genButton("Toggle Board","toggle_board")).insertAfter("#story-author");
$(html_conspiracy_board).insertBefore("#passages");

window.conspiracy_board_toggled = true;


window.toggle_board = function()
{
  window.conspiracy_board_toggled = !window.conspiracy_board_toggled;
  if(window.conspiracy_board_toggled)
  {
    $("#conspiracy_board_overlay").removeClass("conspiracy_board_up");
    $("#conspiracy_board_overlay").addClass("conspiracy_board_down");
  }
  else
  {
    $("#conspiracy_board_overlay").removeClass("conspiracy_board_down");
    $("#conspiracy_board_overlay").addClass("conspiracy_board_up");
  }
};




////////////////////


// Temporary data for debug purposes

window.notesList = [
  {txt:"Wallet stolen by a cat", x:120, y:150},
  {txt:"Cats bring items to Katty", x:100, y:380},
  {txt:"Who has the wallet?", x:300, y:100},
  {txt:"Who is the client?", x:360, y:300}

];

window.linesList = [
  //{start:1,end:2}
];

window.created_pins = []; // will be filled, and store line elements
window.reticule = {};

window.init_conspiracy_board = function()
{
  // Sets canvas to fill all the overlay
  var html_canvas = document.getElementById("cvs_conspiracy_board");
  var parent = document.getElementById("conspiracy_board_overlay");
  html_canvas.width = parent.offsetWidth;
  html_canvas.height = parent.offsetHeight;

var canvas = this.__canvas = new fabric.Canvas('cvs_conspiracy_board', { selection: false,
preserveObjectStacking: true // important to prevent object from changing layers when selected or moved
});

fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';

var settings = {};
settings.noteWidth = 100;
settings.noteHeight = 100;
settings.notePadding = 6;


/*
  lines are directed: they begin at a specific note, and enf at another
  when moving a note, they must update the lines if they're at the end of a line
  or a at their start

*/

function makeNote(external_id, text, left, top, pin)
{
  var rect = new fabric.Rect({
    left: left,
    top: top,
    width:settings.noteWidth,
    height:settings.noteHeight,
    fill: '#FEFF9C',
    angle:3,
  });

  var textObject = new fabric.Textbox(text, {
   left: left+settings.notePadding/2,
   top: top+settings.notePadding/2,
   width:settings.noteWidth-settings.notePadding/2,
   fontFamily:"Caveat",
   fontSize: 19,
   fill: '#000000'
  });

var group = new fabric.Group([rect, textObject],
  {
    external_id:external_id,
    object_type:"note",
    left: left,
    top: top,
    width:settings.noteWidth,
    height:settings.noteHeight,
    pin:pin,

  });

  group.hasControls = group.hasBorders = false;

  return group;
}

function makeLine(start_pin_id, end_pin_id)
{

  var start_pin = created_pins[start_pin_id];
  var end_pin = created_pins[end_pin_id];

  var line = new fabric.Line([start_pin.left, start_pin.top,end_pin.left, end_pin.top], {
    start_pin_id:start_pin_id,
    end_pin_id:end_pin_id,
    object_type:'line',
    fill: 'red',
    stroke: 'red',
    strokeWidth: 4,
    normalColor:'red',
    darkColor:'#680000',
    perPixelTargetFind:true,
    targetFindTolerance:10,
    selectable: false,
    evented: true,
    hoverCursor:"pointer",
  });

    line.hasControls = line.hasBorders = false;


    start_pin.addLine(start_pin, line, "start");
    end_pin.addLine(end_pin, line, "end");

    return line;
}

function makePin(external_id, x, y)
{
  var pin = new fabric.Circle({
    external_id:external_id,
      left: x,
      top: y,
      object_type:'pin',
      strokeWidth: 5,
      radius: 12,
      fill: '#fff',
      stroke: '#666',
      lines_start:[],
      lines_end:[],
      hoverCursor:'pointer',
      selectable: false,
      evented: true,
    });

    pin.movePin = function(pin,x,y)
    {

      for(i in pin.lines_start)
      {
        pin.lines_start[i].set({x1:x,y1:y});
        pin.lines_start[i].setCoords();
      }
      for(i in pin.lines_end)
      {
        pin.lines_end[i].set({x2:x,y2:y});
        pin.lines_end[i].setCoords();
      }

      pin.set({left:x, top:y});
      pin.setCoords();
    }

    pin.addLine = function(pin, line, edge_type)
    {
      if(edge_type == "start")
      {
        pin.lines_start.push(line);
      }else if(edge_type == "end")
      {
        pin.lines_end.push(line);
      }

    }

    pin.on('click',function(e)
  {
    alert("click");
  });


    pin.hasControls = pin.hasBorders = false;
  return pin;
}


function makeReticule()
{

    var line = new fabric.Line([0,0,0,0], {
      object_type:'line',
      stroke: 'red',
      strokeDashArray: [5, 5],
      strokeWidth: 5,
      selectable: false,
      evented:false,
      opacity:0,
    });

    var visor = new fabric.Circle({
        left: 0,
        top: 0,
        object_type:'visor',
        strokeWidth: 5,
        radius: 12,
        stroke: 'red',
        fill:'transparent',
        selectable: false,
        evented:false,
        opacity:0,
      });


    var reticule =
      {
        start_pin:null,
        visor:visor,
        line:line,
        active:false,
      };

      reticule.moveVisor = function(reticule, x, y)
      {
        reticule.visor.set({left:x, top:y});
        reticule.visor.setCoords();
        reticule.line.set({x2:x, y2:y});
        reticule.line.setCoords();
      }

      reticule.addToCanvas = function(canvas, reticule)
      {
        canvas.add(reticule.line);
        canvas.add(reticule.visor);
      }

      reticule.hide = function(reticule)
      {
        reticule.visor.opacity = 0;
        reticule.line.opacity = 0;
        reticule.active = false;
      }

      reticule.show = function(reticule)
      {
        reticule.visor.opacity = 1;
        reticule.line.opacity = 1;
        reticule.active = true;
      }

      reticule.startFromPin = function(reticule, start_pin)
      {
        reticule.start_pin = start_pin;
        reticule.line.set({x1:start_pin.left, y1:start_pin.top});
        reticule.line.setCoords();
        reticule.moveVisor(reticule, start_pin.left, start_pin.top);
      }

      return reticule;
}
  // Create notes and remember their pins
  for(var i = 0; i < notesList.length; i++)
  {
    var note = notesList[i];
    var pin = makePin(i, note.x, note.y-settings.noteHeight/2);
    var note = makeNote(i, note.txt, note.x, note.y, pin);

    //created_notes.push(note);
    created_pins.push(pin);

    canvas.add(note);

    //Ad pins later, for z order
    //canvas.add(pin);
  }

  // Create lines
  for(var i = 0; i < linesList.length;i++)
  {
    var start_pin_id = linesList[i].start;
    var end_pin_id = linesList[i].end;
    var line = makeLine(start_pin_id, end_pin_id);

    canvas.add(line);
  }


  // Add pins
  for(var i = 0; i < created_pins.length; i++)
  {
    canvas.add(created_pins[i]);
  }

  //Add reticule

  window.reticule = makeReticule();
  var reticule = window.reticule;
  //reticule.startFromPin(created_pins[2]);
  //reticule.show(reticule);
  window.reticule.addToCanvas(canvas, window.reticule);


canvas.on('object:moving', function(e)
{
  var p = e.target;
  if(p && p.object_type == 'note')
  {
    p.pin.movePin(p.pin,p.left, p.top-settings.noteHeight/2)
    // Updates data external strucure about post-its
    // Coordinates change
    window.notesList[p.external_id].x = p.left;
    window.notesList[p.external_id].y = p.top;

    canvas.renderAll();
  }



});


// Move reticule
canvas.on('mouse:move', function(e)
{

  if(window.reticule.active)
  {
    window.reticule.moveVisor(window.reticule, e.pointer.x, e.pointer.y);
    canvas.renderAll();
  }

});


canvas.on('mouse:down', function(e)
{
  var p = e.target;
  if(p && p.object_type == 'pin')
  {

    // Start reticule line if not already active
    if(!window.reticule.active)
    {
      window.reticule.startFromPin(window.reticule, p);
      window.reticule.show(window.reticule);
    }
    else // Create new line
    {
      var start_pin_id = window.reticule.start_pin.external_id;
      var end_pin_id = p.external_id;

      // Checks: do not add a line that already exists
      // start and end should be different

      var existence_check = true;
      for(var i in linesList)
      {
        var a = linesList[i].start;
        var b = linesList[i].end;
        if( (a == start_pin_id && b == end_pin_id) || ((b == start_pin_id && a == end_pin_id)) )
        {
          existence_check = false;
        }
      }

      if(existence_check && start_pin_id != end_pin_id)
      {
        linesList.push({start:start_pin_id, end:end_pin_id});

        var line = makeLine(start_pin_id, end_pin_id);
        canvas.add(line);
        window.reticule.hide(reticule);
        resortAllElements(canvas);
      }

    }
  }
  else if (p && p.object_type == "line")
  {
      // Remove line from data structure and canvas

    var remove_index = null;
    for(var i =0; i < linesList.length; i++)
    {
      var a = linesList[i].start;
      var b = linesList[i].end;
      if( (a == p.start_pin_id && b == p.end_pin_id) || ((b == p.start_pin_id && a == p.end_pin_id)) )
      {
        remove_index = i;
      }
    }
    if(remove_index !== null)
    {
      window.linesList.splice(remove_index, 1);
    }
    else
    {
      console.log("line_error", p.start_pin_id, p.end_pin_id)
    }

    canvas.remove(p);

  }

  // Cancel reticule if click in empty space
  else if(!p && window.reticule.active)
  {
    window.reticule.hide(reticule);
    resortAllElements(canvas);
  }


});

// Line color hovering
canvas.on('mouse:over',function(e)
{
  var p = e.target;
  if(p && p.object_type == "line")
  {
    p.set({stroke:p.darkColor});
    canvas.renderAll();
  }
})

canvas.on('mouse:out',function(e)
{
  var p = e.target;
  if(p && p.object_type == "line")
  {
    p.set({stroke:p.normalColor});
    canvas.renderAll();
  }
})


// Sort z index: keep the one for notes and lines, then reticule line, then pins, then reticule visor
function resortAllElements(canvas)
{
  canvas.bringToFront(window.reticule.line);
  for(var j in created_pins)
  {
    canvas.bringToFront(created_pins[j]);
  }
  canvas.bringToFront(window.reticule.visor);
}
  canvas.renderAll();

}
